<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <link href="prism.css" rel="stylesheet">
  <style>
    pre[class*="language-"] {
          font-size: 12px;
          font-style: normal;
          font-family: monospace;
          background-color: #ffffff;
    }
    
    span.code {
      font-size: 10pt;
      color: black;
    }
    span.code_comment {
      font-size: 10pt;
      color: green;
    }
  </style>
  <title></title>
</head>

<body>
<script type="text/javascript" src="prism.js">
</script>
<script type="text/javascript" src="prism_keep_tag.js">
</script>

<h3>SVG Text to Paths Conversion</h3>

<p></p>

<h3>Introduction</h3>

<p>The conversion of text given in svg files (<code>&lt;text&gt;</code> elements) 
to paths (<code>&lt;path&gt;</code> elements) seems to be a common concern. 
There are in Internet plenty of projects/discussions on the topic.</p>

<p>For every language it seems that many solutions are given. Unfortunately, as
far as I could observe, there is plenty of crap (unfinished packages, or deprecated etc.).
This is especially the case when searching for solutions for the python language 
(which is quite a shame)!</p>

<p></p>

<p>I finally found only <strong>1 (!)</strong> python package that seems to
make the conversion in a reasonable way:</p>
<ul>
  <li><strong>ziafont (version 0.2)</strong> (as 15.01.2022)</li>
</ul>

<p>This package reads the true type font binary files (which is a whole task in
its own) and thus has access to every bit of the files. Paths can then be
calculated and exported. A quick try shown me how good this package is. Diving
into the code shows how deep the author of the package knows true type stuff. I
only found one drawback: the output is full of "viewbox" fitting exactly the
size of the output paths, and these viewboxes are often with negative values.
Because of this, it is not so straightforward (for me) to use the output and to
plug it into the user own svg file as one would wish. This is because I
personnaly prefer in an svg file only 1 viewbox definition (at the top)
starting at (0, 0) with <strong>w</strong> and <strong>h</strong> equals to the
svg "<strong>width</strong>" and "<strong>height</strong>". Negative
<strong>x</strong> or <strong>y</strong> viewboxes are simply a pain.</p>

<p></p>

<p>An other method would be to use the python package
"<strong>freetype-py</strong>". This package performs the task of reading the
binary files, and it is possible to generate the paths from the
structures/objects that freetype-py offers. These are infact ctypes wrappers,
and as a good (excellent) wrapper, many functions of the freetype c library are
accessible as methods of these objects. Hopefully all informations of the fonts
are accessible!</p>

<p>This is the approach that I follow in my package, and because of this, my
code is much smaller than the <strong>ziafont</strong> one. But I am quite sure
that <strong>ziafont</strong> is much more robust/bug free as my
<strong>svgtext2svgpaths</strong> package.</p>

<p>By the way, freetype-py performs only 'kern'
kerning, not 'GPOS' kerning (as far as I understand). The GPOS table seems not
to be accessible from freetype-py, so I use <strong>ziafont</strong> code to load this table.
<strong>Thank you ziafont!</strong> So eventually I pick  from ziafont
the following files for my task: gpos.py and fontread.py.</p>

<p></p>

<h3>The svgtext2svgpaths package</h3>

<p>The features of my package are directly dictated from the need to convert
svg <code>&lt;text&gt;</code> to svg <code>&lt;path&gt;</code> elements inside a svg file.
How does the result of the conversion has to look like?</p>
<ul>
  <li>It must be <strong>without</strong> any "<strong>transforms</strong>"
    attributes.</li>
  <li>the <strong>location</strong> of the text described by the path(s) must
    match exactly the same input <code>&lt;text&gt;</code> which is given in svg by the
    "<strong>x</strong>" and "<strong>y</strong>" attributes.</li>
  <li>the <strong>size</strong> of the letters described by the paths must be
    exactly the same as the one given in the <code>&lt;text&gt;</code> data: the 
    "<strong>font-size</strong>" expressed in units "<strong>px</strong>".</li>
  <li>and of course, font <strong>family</strong> and others (<strong>font-style</strong>, 
  <strong>font-weight</strong> and <strong>font-stretch</strong>)
    must be respected, as far as possible.</li>
</ul>

<p>It cannot handle the following strings:</p>
<ul>
  <li><strong>strings splitted on many lines (ziafont can)</strong></li>
  <li><strong>strings with different styles for separate chars in the string</strong></li>
</ul>

<p></p>

<h3>Fonts in svg</h3>

<p>From the Inkscape App, a text is entered, for example
<code>BB CC AA BB</code>. The font family / type can be chosen as well as the
font-size, given in "<strong>pt</strong>". Saving this file, we can observe in
the svg file that the svg font size is different than the one in the Inkscape App: in "<strong>px</strong>".</p>

<p>Note that a <code>&lt;text&gt;</code> definition in svg from Inkscape looks
like: </p>
<pre><code class="language-xml" data-keep-tags="strong">
  &lt;text
       xml:space="preserve"
       style="<strong>font-style</strong>:normal;font-variant:normal;<strong>font-weight</strong>:normal;<strong>font-stretch</strong>:normal;<strong>font-size</strong>:10.5833px;line-height:1.25;<strong>font-family:Arial;</strong>-inkscape-font-specification:'Arial, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.264583"
       x="9.7133684"
       y="41.712864"
       id="text1314"&gt;
    &lt;tspan
         sodipodi:role="line"
         id="tspan1312"
         style="<strong>font-style</strong>:normal;font-variant:normal;<strong>font-weight</strong>:normal;<strong>font-stretch</strong>:normal;<strong>font-size</strong>:10.5833px;<strong>font-family:Arial;</strong>-inkscape-font-specification:'Arial, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;stroke-width:0.264583"
         x="9.7133684"
         y="41.712864"&gt;BB  CC  AA  BB
    &lt;tspan&gt;
  &lt;/text&gt;</code></pre>

<p>but one could simplify it per hand:</p>

<pre><code class="language-xml" data-keep-tags="strong">
  &lt;text style="<strong>font-style</strong>:normal;<strong>font-weight</strong>:normal;<strong>font-stretch</strong>:normal;<strong>font-size</strong>:10.5833px;<strong>font-family:Arial;</strong>fill:#000000;fill-opacity:1;"
       x="9.7133684"
       y="41.712864"
       id="text1314"&gt;BB  CC  AA  BB&lt;/text&gt;</code></pre>

<p>
The color and opacity do not play a role when cutting, but it is nice to have these properties in the resulting paths. 
Infact, the path elements resulting from the conversion will be shown in the svg viewer, so eventually they should 
have at least the same color as the original text, as well as all other properties.</p>

<p>The value of the text is found as value of the XML <code>&lt;text&gt;</code>
  element, or as value(s) of the XML <code>&lt;tspan&gt;</code> element(s) found
  inside the <code>&lt;text&gt;</code> element. So a converter has to correctly
  parse the XML <code>&lt;text&gt;</code> element.</p>
  
<h4>Fonts style</h4>

<p>Whatever the conversion is, we have anyway the <strong>font-size</strong> property in
  the svg file and we will use it for the conversion to

  family</strong> and other font properties (in the svg text "style" attribute): the
  <strong>font-style</strong>, <strong>font-weight</strong> and
  <strong>font-stretch</strong> attributes will also be taken into account when possible.</p>

<h4>Note on the font size</h4>

<p>In Inkscape, font size in given in <strong>pt</strong> units.

<p>Units conversion is as following:</p>

<p>https://oreillymedia.github.io/Using_SVG/guide/units.html</p>
<ul>
  <li>1 px = 3/4 pt</li>
  <li>1 inch = 25.4 mm</li>
  <li>Inkscape resolution: 96 px per inch</li>
</ul>

<p>So when giving in Inkscape a font soze of <strong>30 pt</strong>: 30 pt are 40 px are (40/96) * 25.4 mm =
<strong>10.5833</strong>. This is the value found in the svg file, with units
"<strong>px</strong>".</p>



<h3>Font Files</h3>

<p>Next, we need something like a "lookup" to find the <strong>ttf</strong>
files with the given font family and style. In order to simplify the lookup of the fonts, 
a python module (mine is named <code>pycut_fonts_text2path.py</code>) is given describing where to find the fonts files.</p>

<p>This module is then specified with absolute path in the environment variable <strong>PYCUT_FONTS_TEXT_2_PATHS</strong>. (no .py ending)</p>

<p>All the font files found in the specified font directories are read to extract the font family and others font styles.
As example of a <code>pycut_fonts_text2path.py</code>:</p>

<pre><code class="language-python"># -*- coding: utf-8 -*-
 
fonts_dirs = [
    "C:\\Windows\\Fonts",
    "./fonts/slaine"
]

fonts_family_alias = {
    "sans-serif": "microsoft sans serif",

    #'Sláine': 'Sláine Standard'
    'sláine': 'sl?ine'
}
</code></pre>
<p>The <code>fonts_family_alias</code> dictionary is used to map the font family name from the svg text style (in UTF-8) 
to the 'real' (?) font family name, when there is not match. In this case we see that the "sans-serif" font family
does not exist in all the font files found in the <code>"C:\\Windows\\Fonts"</code> folder, but there is a quite similar font named "microsoft sans serif". The font "Slaine" 
is also not found in the <code>slaine.ttf</code> font file, but in it it describes the font <code>'sl?ine'</code> : the ascii repr of the utf-8 name (i did
not succeeded to read the utf-8 name from the freetype-py lib)</p>

<p>In case of the svg font family and style are not found in the lookup data, an error is printed and no conversion occurs.</p>

<h3>Usage</h3>

<h4>Example</h4>

<pre><code class="language-python"># -- from a "raw" svg file
converter = SvgTextConverter("./examples/slaine.svg")
svg = converter.transform_svg()
print(svg)
</code></pre>

<p>As you can see, conversion is straightforward. Especially, there are no spurious viewboxes around.
All characters, the ones fron the <code>text</code> elements and the ones from the <code>path</code> elements, should overlap!</p>
</body>
</html>
